// ========================================================================== //
//                         - Class_SurfTri -                                  //
//                                                                            //
// Grid manager for unstructured meshes.                                      //
// ========================================================================== //
// INFO                                                                       //
// ========================================================================== //
// Author   : Alessandro Alaia                                                //
// Version  : v3.0                                                            //
//                                                                            //
// All rights reserved.                                                       //
// ========================================================================== //

// ========================================================================== //
// INCLUDES                                                                   //
// ========================================================================== //
# include "Class_SurfTri.hpp"

// ========================================================================== //
// GLOBAL CONSTANTS                                                           //
// ========================================================================== //
double const      pi = 3.14159265358979;

// ========================================================================== //
// IMPLEMENTATIONS                                                            //
// ========================================================================== //

// -------------------------------------------------------------------------- //
dvector1D Class_SurfTri::Baricenter(
    int          T
) {

// ========================================================================== //
// dvector1D Class_SurfTri::Baricenter(                                       //
//     int          T)                                                        //
//                                                                            //
// Compute simplex baricenter.                                                //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T     : int, simplex global index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - P     : dvector1D, with simplex baricenter coordinates                   //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int            dim = Vertex[0].size();
dvector1D      P(dim, 0.0);

// Counters
int            i, j, m;

// ========================================================================== //
// COMPUTE SIMPLEX BARICENTER                                                 //
// ========================================================================== //
m = Simplex[T].size();
for (i = 0; i < m; i++) {
    for (j = 0; j < dim; j++) {
        P[j] += Vertex[Simplex[T][i]][j];
    } //next j
} //next i
for (j = 0; j < dim; j++) {
    P[j] = P[j]/((double) m);
} //next j

return(P); };

// -------------------------------------------------------------------------- //
dvector1D Class_SurfTri::Baricenter(
    int          T,
    dvector2D   &V
) {

// ========================================================================== //
// dvector1D Class_SurfTri::Baricenter(                                       //
//     int          T,                                                        //
//     dvector2D   &V)                                                        //
//                                                                            //
// Compute simplex baricenter. Vertex coordinate list is provided externally  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T     : int, simplex global index                                        //
// - V        : dvector2D with vertex coordinate list. X[i][0], X[i][1], ...  //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - P     : dvector1D, with simplex baricenter coordinates                   //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int            dim = V[0].size();
dvector1D      P(dim, 0.0);

// Counters
int            i, j, m; 

// ========================================================================== //
// COMPUTE SIMPLEX BARICENTER                                                 //
// ========================================================================== //
m = Simplex[T].size();
for (i = 0; i < m; i++) {
    for (j = 0; j < dim; j++) {
        P[j] += V[Simplex[T][i]][j];
    } //next j
} //next i
for (j = 0; j < dim; j++) {
    P[j] = P[j]/((double) m);
} //next j

return(P); };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minEdge(
    double      &edge,
    int         &T,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::minEdge(                                               //
//     double      &edge,                                                     //
//     int         &T,                                                        //
//     int         &i)                                                        //
//                                                                            //
// Compute the minimal edge length over all simplicies in the tasselation,    //
// and returns the global index of simplex and the local index of edge at     //
// min edge.                                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - edge      : double, minimal edge length                                  //
// - T         : int, simplex global index                                    //
// - i         : int, edge local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      ddummy;

// Counters
int         I_, j;

// ========================================================================== //
// FIND MINIMAL EDGE LENGTH                                                   //
// ========================================================================== //
T = 0;
minEdge(T, edge, i);
for (I_ = 0; I_ < nSimplex; I_++) {
    minEdge(I_, ddummy, j);
    if (ddummy < edge) {
        T = I_;
        edge = ddummy;
        i = j;
    }
} //next T

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::minEdge(
    dvector2D   &V,
    double      &edge,
    int         &T,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::minEdge(                                               //
//     dvector2D   &V,                                                        //
//     double      &edge,                                                     //
//     int         &T,                                                        //
//     int         &i)                                                        //
//                                                                            //
// Compute the minimal edge length over all simplicies in the tasselation,    //
// and returns the global index of simplex and the local index of edge at     //
// min edge. Vertex list is provided externally.                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V         : dvector2D; vertex coordinate list. V[i][0], V[i][1], ...     //
//               are the x, y, ... coordinates of the i-th vertex             //
// - edge      : double, minimal edge length                                  //
// - T         : int, simplex global index                                    //
// - i         : int, edge local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      ddummy;

// Counters
int         I_, j;

// ========================================================================== //
// FIND MINIMAL EDGE LENGTH                                                   //
// ========================================================================== //
T = 0;
minEdge(V, T, edge, i);
for (I_ = 0; I_ < nSimplex; I_++) {
    minEdge(V, I_, ddummy, j);
    if (ddummy < edge) {
        T = I_;
        edge = ddummy;
        i = j;
    }
} //next T

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::minEdge(
    int          T,
    double      &edge,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::minEdge(                                               //
//     int          T,                                                        //
//     double      &edge,                                                     //
//     int         &i)                                                        //
//                                                                            //
// Return length of simplex' minimal edge.                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T    : int, simplex global index                                         //
// - edge : double, min edge length                                           //
// - i    : int, edge local index                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int            dim = Vertex[0].size();
double         length;

// Counters
int            j, k, m;

// ========================================================================== //
// COMPUTE MIN EDGE                                                           //
// ========================================================================== //
edge = norm_2(Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]]);
i = 0;
m = Simplex[T].size();
for (j = 1; j < m; j++) {
    k = (j + 1) % m;

    // Edge length
    length = norm_2(Vertex[Simplex[T][k]] - Vertex[Simplex[T][j]]);
    if (length < edge) {
        edge = length;
        i = j;
    }
} //next j

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minEdge(
    dvector2D   &V,
    int          T,
    double      &edge,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::minEdge(                                               //
//     dvector2D   &V,                                                        //
//     int          T,                                                        //
//     double      &edge,                                                     //
//     int         &i)                                                        //
//                                                                            //
// Return simplex minimal edge. Vertex coordinate list is provided externally //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V    : dvector2D, with vertex coordinate list. V[i][0], V[i][1], ... are //
//          the x, y, ... coordinates of the i-th vertex                      //
// - T    : int, simplex global index                                         //
// - edge : double, min edge length                                           //
// - i    : int, edge local index                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int            dim = V[0].size();
double         length;

// Counters
int            j, k, m;

// ========================================================================== //
// COMPUTE MIN EDGE                                                           //
// ========================================================================== //
edge = norm_2(V[Simplex[T][1]] - V[Simplex[T][0]]);
i = 0;
m = Simplex[T].size();
for (j = 1; j < m; j++) {
    k = (j + 1) % m;

    // Edge length
    length = norm_2(V[Simplex[T][k]] - V[Simplex[T][j]]);
    if (length < edge) {
        edge = length;
        i = j;
    }
} //next j

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxEdge(
    double      &edge,
    int         &T,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::maxEdge(                                               //
//     double      &edge,                                                     //
//     int         &T,                                                        //
//     int         &i)                                                        //
//                                                                            //
// Compute the maximal edge length over all simplicies in the tasselation,    //
// and returns the global index of simplex and the local index of edge at     //
// max edge.                                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - edge      : double, maximal edge length                                  //
// - T         : int, simplex global index                                    //
// - i         : int, edge local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      ddummy;

// Counters
int         I_, j;

// ========================================================================== //
// FIND MINIMAL EDGE LENGTH                                                   //
// ========================================================================== //
T = 0;
maxEdge(T, edge, i);
for (I_ = 0; I_ < nSimplex; I_++) {
    maxEdge(I_, ddummy, j);
    if (ddummy > edge) {
        T = I_;
        edge = ddummy;
        i = j;
    }
} //next T

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxEdge(
    dvector2D   &V,
    double      &edge,
    int         &T,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::maxEdge(                                               //
//     dvector2D   &V,                                                        //
//     double      &edge,                                                     //
//     int         &T,                                                        //
//     int         &i)                                                        //
//                                                                            //
// Compute the maximal edge length over all simplicies in the tasselation,    //
// and returns the global index of simplex and the local index of edge at     //
// max edge. Vertex list is provided externally.                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V         : dvector2D; vertex coordinate list. V[i][0], V[i][1], ...     //
//               are the x, y, ... coordinates of the i-th vertex             //
// - edge      : double, maximal edge length                                  //
// - T         : int, simplex global index                                    //
// - i         : int, edge local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      ddummy;

// Counters
int         I_, j;

// ========================================================================== //
// FIND MINIMAL EDGE LENGTH                                                   //
// ========================================================================== //
T = 0;
maxEdge(V, T, edge, i);
for (I_ = 0; I_ < nSimplex; I_++) {
    maxEdge(V, I_, ddummy, j);
    if (ddummy < edge) {
        T = I_;
        edge = ddummy;
        i = j;
    }
} //next T

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxEdge(
    int          T,
    double      &edge,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::maxEdge(                                               //
//     int          T,                                                        //
//     double      &edge,                                                     //
//     int         &i)                                                        //
//                                                                            //
// Return simplex maximal edge.                                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T    : int, simplex global index                                         //
// - edge : double, max edge length                                           //
// - i    : int, edge local index                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int            dim = Vertex[0].size();
double         length;

// Counters
int            j, k, m;

// ========================================================================== //
// COMPUTE MIN EDGE                                                           //
// ========================================================================== //
edge = norm_2(Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]]);
i = 0;
m = Simplex[T].size();
for (j = 1; j < m; j++) {
    k = (j + 1) % m;

    // Edge length
    length = norm_2(Vertex[Simplex[T][k]] - Vertex[Simplex[T][j]]);
    if (length > edge) {
        edge = length;
        i = j;
    }
} //next j

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxEdge(
    dvector2D   &V,
    int          T,
    double      &edge,
    int         &i
) {

// ========================================================================== //
// void Class_SurfTri::maxEdge(                                               //
//    dvector2D   &V,                                                         //
//    int          T,                                                         //
//    double      &edge,                                                      //
//    int         &i)                                                         //
//                                                                            //
// Return simplex maximal edge. Vertex coordinate list is provided externally //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V    : dvector2D, with vertex coordinate list. V[i][0], V[i][1], ... are //
//          the x, y, ... coordinates of the i-th vertex                      //
// - T    : int, simplex global index                                         //
// - edge : double, max edge length                                           //
// - i    : int, edge local index                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int            dim = V[0].size();
double         length;

// Counters
int            j, k, m;

// ========================================================================== //
// COMPUTE MIN EDGE                                                           //
// ========================================================================== //
edge = norm_2(V[Simplex[T][1]] - V[Simplex[T][0]]);
i = 0;
m = Simplex[T].size();
for (j = 1; j < m; j++) {
    k = (j + 1) % m;

    // Edge length
    length = norm_2(V[Simplex[T][k]] - V[Simplex[T][j]]);
    if (length > edge) {
        edge = length;
        i = j;
    }
} //next j

return; };

// -------------------------------------------------------------------------- //
double Class_SurfTri::Area(
    void
) {

// ========================================================================== //
// double Class_SurfTri::Area(                                                //
//     void)                                                                  //
//                                                                            //
// Compute tasselation area.                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double          A = 0.0;

// Counters
int             T;

// ========================================================================== //
// COMPUTE TASSELATION AREA                                                   //
// ========================================================================== //
for (T = 0; T < nSimplex; T++) {
    A += Area(T);
} //next T

return(A); }

// -------------------------------------------------------------------------- //
double Class_SurfTri::Area(
    dvector2D   &V
) {

// ========================================================================== //
// double Class_SurfTri::Area(                                                //
//     dvector2D   &V)                                                        //
//                                                                            //
// Compute tasselation area. Vertex list is provided externally               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double          A = 0.0;

// Counters
int             T;

// ========================================================================== //
// COMPUTE TASSELATION AREA                                                   //
// ========================================================================== //
for (T = 0; T < nSimplex; T++) {
    A += Area(T, V);
} //next T

return(A); }

// -------------------------------------------------------------------------- //
double Class_SurfTri::Area(
    int          T
) {

// ========================================================================== //
// double Class_SurfTri::Area(                                                //
//     int T)                                                                 //
//                                                                            //
// Compute the area of a convex simplex                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T        : int, simplex index                                            //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - Area     : double, simplex area                                          //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                    dim = Vertex[0].size();
double                 A;

// Counters
int                    i, j, m;

// ========================================================================== //
// COMPUTE THE AREA                                                           //
// ========================================================================== //
m = Simplex[T].size();
if (m == 1) {

    // Point ---------------------------------------------------------------- //
    A = 0.0;

}
else if (m == 2) {

    // Segment -------------------------------------------------------------- //
    A = norm_2(Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]]);

}

else if (m == 3) {

    // Triangle ------------------------------------------------------------- //
    A = 0.5 * norm_2(Cross_Product(Vertex[Simplex[T][1]] - Vertex[Simplex[T][0]],
                                   Vertex[Simplex[T][2]] - Vertex[Simplex[T][0]]));
}

else {

    // non-degenerate simplex ----------------------------------------------- //

    // Compute simplex-area
    A = 0.0;
    for (i = 1; i < m; i++) {
        j = (i+1) % m;
        A += 0.5 * norm_2(Cross_Product(
                          Vertex[Simplex[T][i]] - Vertex[Simplex[T][0]],
                          Vertex[Simplex[T][j]] - Vertex[Simplex[T][0]]));
    } //next i
}

return(A); };

// -------------------------------------------------------------------------- //
double Class_SurfTri::Area(
    int          T,
    dvector2D   &V
) {

// ========================================================================== //
// double Class_SurfTri::Area(                                                //
//     int          T,                                                        //
//     dvector2D   &V)                                                        //
//                                                                            //
// Compute the area of a convex simplex. Vertex list is provided externally   //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T        : int, simplex index                                            //
// - V        : dvector2D, vertex coordinate list. X[i][0], X[i][1], ...      //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - Area     : double, triangle area                                         //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                    dim = V[0].size();
double                 A;

// Counters
int                    i, j, m;

// ========================================================================== //
// COMPUTE THE AREA                                                           //
// ========================================================================== //
m = Simplex[T].size();

// Point -------------------------------------------------------------------- //
if (m == 1) {

    // Compute area
    A = 0.0;

}

// Segment ------------------------------------------------------------------ //
else if (m == 2) {

    // Compute area
    A = norm_2(V[Simplex[T][1]] - V[Simplex[T][0]]);

}

// Triangle ----------------------------------------------------------------- //
else if (m == 3) {

    // Compute triangle's area
    A = 0.5 * norm_2(Cross_Product(V[Simplex[T][1]] - V[Simplex[T][0]],
                                   V[Simplex[T][2]] - V[Simplex[T][0]]));
}

// Non-degenerate simplex --------------------------------------------------- //
else {

    // Compute simplex area
    A = 0.0;
    for (i = 1; i < m; i++) {
        j = (i+1) % m;
        A += 0.5 * norm_2(Cross_Product(
                          V[Simplex[T][i]] - V[Simplex[T][0]],
                          V[Simplex[T][j]] - V[Simplex[T][0]]));
    } //next i
}

return(A); };

// -------------------------------------------------------------------------- //
void Class_SurfTri::Area(
    dvector1D   &A
) {

// ========================================================================== //
// void Class_SurfTri::Area(                                                  //
//     dvector1D   &A)                                                        //
//                                                                            //
// Compute the area of each simplex in the surface tasselation                //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - A     ; dvector1D, storing the area value of each simplex                //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
A.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE AREA OF EACH SIMPLEX                                               //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    A[i] = Area(i);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::Area(
    dvector2D   &V,
    dvector1D   &A
) {

// ========================================================================== //
// void Class_SurfTri::Area(                                                  //
//     dvector2D   &V,                                                        //
//     dvector1D   &A)                                                        //
//                                                                            //
// Compute the area of each simplex in a surface tasselation. Vertex          //
// coordinate list is provided externally.                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V     : dvector2D, vertex coordinate list. V[i][0], V[i][1], ... are     //
//           the x, y, ... coordinates of the i-th vertex.                    //
// - A     ; dvector1D, storing the area value of each simplex                //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i;


// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
A.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE AREA OF EACH SIMPLEX                                               //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    A[i] = Area(i, V);
} //next i

return; }

// -------------------------------------------------------------------------- //
double Class_SurfTri::AR(
    int          T
) {

// ========================================================================== //
// double Class_SurfTri::AR(                                                  //
//     int          T)                                                        //
//                                                                            //
// Compute the aspect ratio of a given simplex in the tasselation.            //
// Aspect ratio is defined as the ratio between the longest and               //
// shortes edges in the simplex.                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T      : int, simplex index.                                             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - aspect : double, simplex aspect ratio                                    //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int          dim = Vertex[0].size();
double       aspect = 0.0;
double       min_edge, max_edge, edge;

// Counters
int          i, j, m = Simplex[T].size();

// ========================================================================== //
// COMPUTE AR.                                                                //
// ========================================================================== //
min_edge = max_edge = norm_2(Vertex[Simplex[T][0]] - Vertex[Simplex[T][1]]);
for (i = 1; i < m; i++) {
    j = (i+1) % m;
    edge = norm_2(Vertex[Simplex[T][i]] - Vertex[Simplex[T][j]]);
    min_edge = min(min_edge, edge);
    max_edge = max(max_edge, edge);
} //next i
aspect = max_edge/min_edge;

return (aspect); };

// -------------------------------------------------------------------------- //
double Class_SurfTri::AR(
    int          T,
    dvector2D   &V
) {

// ========================================================================== //
// double Class_SurfTri::AR(                                                  //
//     int          T,                                                        //
//     dvector2D   &V)                                                        //
//                                                                            //
// Compute the aspect ratio of a given simplex in the tasselation.            //
// Aspect ratio is defined as the ratio between the longest and               //
// shortes edges in the simplex.                                              //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T      : int, simplex index.                                             //
// - V        : dvector2D with vertex coordinate list. X[i][0], X[i][1], ...  //
//              are the x, y, ... coordinates of the i-th vertex.             //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - aspect : double, simplex aspect ratio                                    //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int          dim = V[0].size();
double       aspect = 0.0;
double       min_edge, max_edge, edge;

// Counters
int          i, j, m = Simplex[T].size();

// ========================================================================== //
// COMPUTE AR.                                                                //
// ========================================================================== //
min_edge = max_edge = norm_2(V[Simplex[T][0]] - V[Simplex[T][1]]);
for (i = 1; i < m; i++) {
    j = (i+1) % m;
    edge = norm_2(V[Simplex[T][i]] - V[Simplex[T][j]]);
    min_edge = min(min_edge, edge);
    max_edge = max(max_edge, edge);
} //next i
aspect = max_edge/min_edge;

return (aspect); };

// -------------------------------------------------------------------------- //
void Class_SurfTri::AR(
    dvector1D   &aspect
) {

// ========================================================================== //
// void Class_SurfTri::AR(                                                    //
//     dvector1D   &aspect)                                                   //
//                                                                            //
// Compute the aspect ratio of each simplex in the tasselation.               //
// Aspect ratio is defined as the ratio between the longest                   //
// and shortes edges in the simplex.                                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - aspect : double, simplex aspect ratio                                    //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int          i;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
aspect.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE AR FOR EACH SIMPLEX IN THE TASSELATION                             //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    aspect[i] = AR(i);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::AR(
    dvector2D   &V,
    dvector1D   &aspect
) {

// ========================================================================== //
// void Class_SurfTri::AR(                                                    //
//     dvector2D   &V,                                                        //
//     dvector1D   &aspect)                                                   //
//                                                                            //
// Compute the aspect ratio of each simplex in the tasselation.               //
// Aspect ratio is defined as the ratio between the longest and               //
// shortes edges in the simplex.                                              //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V      : dvector2D,vertex coordinate list. V[i][0], V[i][1], ... are     //
//            the x, y, ... coordinates of the i-th vertex.                   //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - aspect : double, simplex aspect ratio                                    //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int          i;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
aspect.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE AR FOR EACH SIMPLEX IN THE TASSELATION                             //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    aspect[i] = AR(i, V);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    double      &angle,
    int         &T,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     double      &angle,                                                    //
//     int         &T,                                                        //
//     int         &v)                                                        //
//                                                                            //
// Compute the min angle over all simplicies in the tasselation, and returns  //
// the global index of simplex and the local index of vertex at min angle.    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - angle   : double, min angle value                                        //
// - T       : int, simplex global index                                      //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      value;

// Counters
int         I_, i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
T = 0;
minAngle(T, angle, v);
for (I_ = 1; I_ < nSimplex; T++) {
    minAngle(I_, value, i);
    if (value < angle) {
        angle = value;
        T = I_;
        v = i;
    }
} //next T

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    dvector2D   &V,
    double      &angle,
    int         &T,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     dvector2D   &V,                                                        //
//     double      &angle,                                                    //
//     int         &T,                                                        //
//     int         &v)                                                        //
//                                                                            //
// Compute the min angle over all simplicies in the tasselation, and returns  //
// the global index of simplex and the local index of vertex at min angle.    //
// Vertex list is provided externally.                                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V       : dvector2D, vertex coordinate list. V[i][0], V[i][1], ...are    //
//             the x, y, ... coordinates of the i-th vertex                   //
// - angle   : double, min angle value                                        //
// - T       : int, simplex global index                                      //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double      value;

// Counters
int         I_, i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
T = 0;
minAngle(T, angle, v);
for (I_ = 1; I_ < nSimplex; T++) {
    minAngle(V, I_, value, i);
    if (value < angle) {
        angle = value;
        T = I_;
        v = i;
    }
} //next T

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    int          T,
    double      &angle,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     int          T,                                                        //
//     double      &angle,                                                    //
//     int         &v)                                                        //
//                                                                            //
// Compute the min angle between two subsequent edges of a given simplex      //
// and returns the min angle.                                                 //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int         dim = Vertex[0].size();
double      value;
dvector1D   v1(dim, 0.0), v2(dim, 0.0);

// Counters
int         i, j, k, m = Simplex[T].size();

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
angle = pi;
for (i = 0; i < m; i++) {
    j = (i + 1) % m;
    k = (i - 1  + m) % m;
    v1 = Vertex[Simplex[T][j]] - Vertex[Simplex[T][i]];
    v2 = Vertex[Simplex[T][k]] - Vertex[Simplex[T][i]];
    v1 = v1/norm_2(v1);
    v2 = v2/norm_2(v2);
    value = acos(max(-1.0, min(1.0, Dot_Product(v1, v2))));
    if (value < angle) {
        angle = value;
        v = i;
    }
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    dvector2D   &V,
    int          T,
    double      &angle,
    int         &v
) {

// ========================================================================== //
// double Class_SurfTri::minAngle(                                            //
//     int T,                                                                 //
//     dvector2D &V)                                                          //
//                                                                            //
// Compute the min angle between two subsequent edges of a given simplex, and //
// returns the min value. Vertex coordinate list is provided externally.      //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V      : dvector2D, vertex coordinate list. V[i][0], V[i][1], ... are    //
//            the x, y, ... coordinates of the i-th vertex.                   //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int         dim = V[0].size();
double      value;
dvector1D   v1(dim, 0.0), v2(dim, 0.0);

// Counters
int         i, j, k, m = Simplex[T].size();

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
angle = pi;
for (i = 0; i < m; i++) {
    j = (i + 1) % m;
    k = (i - 1  + m) % m;
    v1 = V[Simplex[T][j]] - V[Simplex[T][i]];
    v2 = V[Simplex[T][k]] - V[Simplex[T][i]];
    v1 = v1/norm_2(v1);
    v2 = v2/norm_2(v2);
    value = acos(max(-1.0, min(1.0, Dot_Product(v1, v2))));
    if (value < angle) {
        angle = value;
        v = i;
    }
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    dvector1D  &angle
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     dvector1D  &angle)                                                     //
//                                                                            //
// Compute the min angle of each simplex in a surface tasselation             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - angle ; dvector1D, storing the min angle value of each simplex           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i, j;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
angle.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE THE AREA OF A TASSELATION                                          //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    minAngle(i, angle[i], j);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::minAngle(
    dvector2D   &V,
    dvector1D  &angle
) {

// ========================================================================== //
// void Class_SurfTri::minAngle(                                              //
//     dvector2D   &V,                                                        //
//     dvector1D  &angle)                                                     //
//                                                                            //
// Compute the min angle for each simplex in the surface tasselation.         //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V     : dvector2D, vertex coordinate list. V[i][0], V[i][1], ... are     //
//           the x, y, ... coordinates of the i-th vertex.                    //
// - angle : dvector1D, storing the min angle value of each simplex           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i, j;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
angle.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE THE AREA OF A TASSELATION                                          //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    minAngle(V, i, angle[i], j);
} //next i

return; }

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    double      &angle,
    int         &T,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     double      &edge,                                                     //
//     int          T,                                                        //
//     int         &v)                                                        //
//                                                                            //
// Compute the max angle over all simplicies in the tassalation,              //
// and returns the global index of simplex and the local index of vertex      //
// at max angle.                                                              //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double    value;

// Counters
int       I_, i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
T = 0;
maxAngle(T, angle, v);
for (I_ = 1; I_ < nSimplex; I_++) {
    maxAngle(I_, value, i);
    if (value > angle) {
        angle = value;
        T = I_;
        v = i;
    }
} //next i


return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    dvector2D   &V,
    double      &angle,
    int         &T,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     dvector2D   &V,                                                        //
//     double      &edge,                                                     //
//     int          T,                                                        //
//     int         &v)                                                        //
//                                                                            //
// Compute the max angle over all simplicies in the tassalation,              //
// and returns the global index of simplex and the local index of vertex      //
// at max angle. Vertex list is provided externally.                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V       : dvector1D, vertex coordinate list. V[i][0], V[i][1], ... are   //
//             the x, y, ... coordinates of the i-th vertex.                  //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
double    value;

// Counters
int       I_, i;

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
T = 0;
maxAngle(V, T, angle, v);
for (I_ = 1; I_ < nSimplex; I_++) {
    maxAngle(V, I_, value, i);
    if (value > angle) {
        angle = value;
        T = I_;
        v = i;
    }
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    int          T,
    double      &angle,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     int          T,                                                        //
//     double      &edge,                                                     //
//     int         &v)                                                        //
//                                                                            //
// Compute the max angle between two subsequent edges of a given simplex,     //
// and returns the local index of vertex at max angle.                        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int       dim = Vertex[0].size();
double    value;
dvector1D v1(dim, 0.0), v2(dim, 0.0);

// Counters
int       i, j, k, m = Simplex[T].size();

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
angle = 0.0;
for (i = 0; i < m; i++) {
    j = (i + 1) % m;
    k = (i - 1  + m) % m;
    v1 = Vertex[Simplex[T][j]] - Vertex[Simplex[T][i]];
    v2 = Vertex[Simplex[T][k]] - Vertex[Simplex[T][i]];
    v1 = v1/norm_2(v1);
    v2 = v2/norm_2(v2);
    value = acos(max(-1.0, min(1.0, Dot_Product(v1, v2))));
    if (value > angle) {
        angle = value;
        v = i;
    }
} //next i


return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    dvector2D   &V,
    int          T,
    double      &angle,
    int         &v
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     dvector2D   &V,                                                        //
//     int          T,                                                        //
//     double      &angle,                                                    //
//     int         &v)                                                        //
//                                                                            //
// Compute the max angle between two subsequent edges of a given simplex,     //
// and returns the local index of vertex at max angle.                        //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V      : dvector2D, vertex coordinate list. V[i][0], V[i][1], ... are    //
//            x, y, ... coordinates of the i-th vertex.                       //
// - T       : int, simplex global index                                      //
// - angle   : double, min angle value                                        //
// - v       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int       dim = V[0].size();
double    value;
dvector1D v1(dim, 0.0), v2(dim, 0.0);

// Counters
int       i, j, k, m = Simplex[T].size();

// ========================================================================== //
// COMPUTE THE MIN ANGLE.                                                     //
// ========================================================================== //
angle = 0.0;
for (i = 0; i < m; i++) {
    j = (i + 1) & m;
    k = (i - 1  + m) % m;
    v1 = V[Simplex[T][j]] - V[Simplex[T][i]];
    v2 = V[Simplex[T][k]] - V[Simplex[T][i]];
    v1 = v1/norm_2(v1);
    v2 = v2/norm_2(v2);
    value = acos(max(-1.0, min(1.0, Dot_Product(v1, v2))));
    if (value > angle) {
        angle = value;
        v = i;
    }
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    dvector1D   &angle
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     dvector1D   &angle)                                                    //
//                                                                            //
// Compute the max angle of each simplex in the surface tasselation           //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - angle ; dvector1D, storing the max angle value of each simplex           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i, j;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
angle.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE THE AREA OF A TASSELATION                                          //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    maxAngle(i, angle[i], j);
} //next i

return; };

// -------------------------------------------------------------------------- //
void Class_SurfTri::maxAngle(
    dvector2D   &V,
    dvector1D   &angle
) {

// ========================================================================== //
// void Class_SurfTri::maxAngle(                                              //
//     dvector2D   &V,                                                        //
//     dvector1D   &angle)                                                    //
//                                                                            //
// Compute the max angle in each simplex in a surface tasselation.            //
// Vertex coordinate list is provided externally.                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - V     : dvector2D, vertex coordinate list. V[i][0], V[i][1], ... are     //
//           the x, y, ... coordinates of the i-th vertex.                    //
// - angle ; dvector1D, storing the max angle value of each simplex           //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int            i, j;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
angle.resize(nSimplex, 0.0);

// ========================================================================== //
// COMPUTE THE AREA OF A TASSELATION                                          //
// ========================================================================== //
for (i = 0; i < nSimplex; i++) {
    maxAngle(V, i, angle[i], j);
} //next i

return; }

// -------------------------------------------------------------------------- //
dvector1D Class_SurfTri::Edge_midPoint(
    int          T,
    int          e
) {

// ========================================================================== //
// dvector1D Class_SurfTri::Edge_midPoint(                                    //
//     int          T,                                                        //
//     int          e)                                                        //
//                                                                            //
// Compute midpoint of simplex edge.                                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, simplex global index                                      //
// - e       : int, edge local index                                          //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - P       : dvector1D, with midpoint coordinates                           //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                    n, dim = Vertex[0].size();
dvector1D              P(dim, 0.0);

// Counters
int                    j, k;

// ========================================================================== //
// COMPUTE MID POINT FOR A GIVEN EDGE.                                        //
// ========================================================================== //

// Simplex type
n = Simplex[T].size();

// Point
if (n == 1){
    P = Vertex[Simplex[T][e]];
}

// Segment
else if (n == 2) {
    P = Vertex[Simplex[T][e]];
}

// Simplex
else {
    k = (e + 1) % n;
    for (j = 0; j < dim; j++) {
        P[j] = 0.5*(Vertex[Simplex[T][e]][j] + Vertex[Simplex[T][k]][j]);
    } //next j
}

return(P); };

// -------------------------------------------------------------------------- //
dvector1D Class_SurfTri::Edge_midPoint(
    dvector2D   &V,
    int          T,
    int          e
) {

// ========================================================================== //
// dvector1D Class_SurfTri::Edge_midPoint(                                    //
//     dvector2D   &V,                                                        //
//     int          T,                                                        //
//     int          e)                                                        //
//                                                                            //
// Compute mid point of a simplex edge. Vertex list is provided externally    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, Simplex global index                                      //
// - e       : int, edge local index                                          //
// - V       : dvector2D, vertex coordinate list. V[i][0], V[i][1], ... are   //
//             the x, y, ... coordinates of the i-th vertex.                  //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - P       : dvector1D, with mid point coordinates                          //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                    n, dim = Vertex[0].size();
dvector1D              P(dim, 0.0);

// Counters
int                    j, k;

// ========================================================================== //
// COMPUTE MID POINT FOR A GIVEN EDGE.                                        //
// ========================================================================== //

// Simplex type
n = Simplex[T].size();

// Point
if (n == 1) {
    P = V[Simplex[T][e]];
}

// Segment
else if (n == 2) {
    P = V[Simplex[T][e]];
}

// Simplex
else {
    k = (e + 1) % n;
    for (j = 0; j < dim; j++) {
        P[j] = 0.5*(V[Simplex[T][e]][j] + V[Simplex[T][k]][j]);
    } //next j
}

return(P); };

        // ----------------------------------------------------------------------------------- //
        dvector1D Class_SurfTri::CircumCenter(
            int T
        ) {

        // =================================================================================== //
        // dvector1D Class_SurfTri::CircumCenter(                                              //
        //     int T)                                                                          //
        //                                                                                     //
        // Compute simplex circum center. (2-simplicies only).                                 //
        // =================================================================================== //
        // INPUT                                                                               //
        // =================================================================================== //
        // - T        : int, simplex global index                                              //
        // =================================================================================== //
        // OUTPUT                                                                              //
        // =================================================================================== //
        // - P        : dvector1D, with circum center coordinates                              //
        // =================================================================================== //

        // =================================================================================== //
        // VARIABLES DECLARATION                                                               //
        // =================================================================================== //

        // Local variables
        int                 dim = Vertex[0].size();
        dvector1D           P(dim, 0.0);
        array<double, 3>    Q, n, M1, n1, M2, n2;

        // Counters
        int                 i;

        // =================================================================================== //
        // COMPUTE CIRCUMCENTER                                                                //
        // =================================================================================== //

        // Compute triangle normal ----------------------------------------------------------- //

        // Compute bisect. for edge 0. ------------------------------------------------------- //

            // Edge slope
            for (i = 0; i < dim; i++) {
                n1[i] = Vertex[Simplex[T][1]][i] - Vertex[Simplex[T][0]][i];
            } //next i
            n1 = n1/norm_2(n1);

            // Edge mid point
            P = Edge_midPoint(T, 0);
            for (i = 0; i < dim; i++) {
                M1[i] = P[i];
            } //next i

        // Compute bisect. for edge 1. ------------------------------------------------------- //

            // Edge slope
            for (i = 0; i < dim; i++) {
                n2[i] = Vertex[Simplex[T][2]][i] - Vertex[Simplex[T][1]][i];
            } //next i
            n2 = n2/norm_2(n2);

            // Edge mid point
            P = Edge_midPoint(T, 1);
            for (i = 0; i < dim; i++) {
                M2[i] = P[i];
            } //next i

        // Circumcenter coordinates ---------------------------------------------------------- //

            // Triangle's normal
            n = Cross_Product(n1, n2);
            n = n/norm_2(n);

            // Bisect directions
            n1 = Cross_Product(n, n1);
            n2 = Cross_Product(n, n2);

            // Intersection point
            Q = IntersectLines(n1,M1,n2,M2);
            for (i = 0; i < dim; i++) {
                P[i] = Q[i];
            } //next i

        return(P); };

        // ----------------------------------------------------------------------------------- //
        dvector1D Class_SurfTri::CircumCenter(
            int T,
            dvector2D &V
        ) {

        // =================================================================================== //
        // dvector1D Class_SurfTri::CircumCenter(                                              //
        //     int T,                                                                          //
        //     dvector2D &V)                                                                   //
        //                                                                                     //
        // Compute simplex circum center. (2-simplicies only). Vertex coordnate list is        //
        // provided externally.                                                                //
        // =================================================================================== //
        // INPUT                                                                               //
        // =================================================================================== //
        // - T        : int, simplex global index                                              //
        // - V        : dvector2D, with vertex coordinate list. V[i][0], V[i][1], ... are the  //
        //             x, y, ... coordinates of the i-th vertex.                               //
        // =================================================================================== //
        // OUTPUT                                                                              //
        // =================================================================================== //
        // - P        : dvector1D, with circum center coordinates                              //
        // =================================================================================== //

        // =================================================================================== //
        // VARIABLES DECLARATION                                                               //
        // =================================================================================== //

        // Local variables
        int                 dim = V[0].size();
        dvector1D           P(dim, 0.0);
        array<double, 3>    Q, n, M1, n1, M2, n2;

        // Counters
        int                 i;

        // =================================================================================== //
        // COMPUTE CIRCUMCENTER                                                                //
        // =================================================================================== //

        // Compute bisect. for edge 0. ------------------------------------------------------- //

            // Slope
            for (i = 0; i < dim; i++) {
                n1[i] = V[Simplex[T][1]][i] - V[Simplex[T][0]][i];
            } //next i
            n1 = n1/norm_2(n1);

            // Point
            P = Edge_midPoint(V, T, 0);
            for (i = 0; i < dim; i++) {
                M1[i] = P[i];
            } //next i

        // Compute bisect. for edge 1. ------------------------------------------------------- //

            // Slope
            for (i = 0; i < dim; i++) {
                n2[i] = V[Simplex[T][2]][i] - V[Simplex[T][1]][i];
            } //next i
            n2 = n2/norm_2(n2);

            // Point
            P = Edge_midPoint(V, T, 1);
            for (i = 0; i < dim; i++) {
                M2[i] = P[i];
            } //next i

        // Circumcenter coordinates ---------------------------------------------------------- //

            // Triangle's normal
            n = Cross_Product(n1, n2);
            n = n/norm_2(n);

            // Bisect directions
            n1 = Cross_Product(n, n1);
            n2 = Cross_Product(n, n2);

            // Intersection point
            Q = IntersectLines(n1,M1,n2,M2);
            for (i = 0; i < dim; i++) {
                P[i] = Q[i];
            } //next i

        return(P); };

// -------------------------------------------------------------------------- //
int Class_SurfTri::VertexValence(
    int          T,
    int          i
) {

// ========================================================================== //
// int Class_SurfTri::VertexValence(                                          //
//     int          T,                                                        //
//     int          i)                                                        //
//                                                                            //
// Compute valence of a given vertex.                                         //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - T       : int, global index of simplex which vertex belongs to           //
// - i       : int, vertex local index                                        //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - val     : int, vertex valence                                            //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
bool       flag = true;
int        val;
ivector1D  ring1;

// Counters
// none

// ========================================================================== //
// COMPUTE VERTEX VALENCE                                                     //
// ========================================================================== //

// Compute the 1 ring of vertex
ring1 = Ring_1(T, i, flag);

// Valence - closed ring
if (flag) {
    val = ring1.size();
}
// Valence - open ring
else {
    val = ring1.size() + 1;
}

return (val); };

// -------------------------------------------------------------------------- //
void Class_SurfTri::VertexValence(
    ivector1D   &Val
) {

// ========================================================================== //
// void Class_SurfTri::VertexValence(                                         //
//     ivector1D &Val)                                                        //
//                                                                            //
// Compute valence for each vertex in the tasselation                         //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - Val    : ivector1D, with valence score for each vertex                   //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int      V, T, i, m;

// ========================================================================== //
// RESIZE INPUT VARIABLES                                                     //
// ========================================================================== //
Val.resize(nVertex, 0);

// ========================================================================== //
// COMPUTE VERTEX VALENCE                                                     //
// ========================================================================== //

// Reset valence value ------------------------------------------------------ //
for (i = 0; i < nVertex; i++) {
    Val[i] = 0;
} //next i

// Compute valence score ---------------------------------------------------- //
for (T = 0; T < nSimplex; T++) {
    m = Simplex[T].size();
    for (i = 0; i < m; i++) {
        V = Simplex[T][i];
        if (Val[V] == 0) {
            Val[V] = VertexValence(T, i);
        }
    } //next i
} //next T

return; };


