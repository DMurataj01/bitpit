// ========================================================================== //
//                 - GRID MANAGER FOR CARTESIAN MESHES -                      //
//                                                                            //
// Grid manager for cartesian meshes                                          //
// ========================================================================== //
// INFO                                                                       //
// ========================================================================== //
// Author      :   Alessandro Alaia                                           //
// Version     :   v2.0                                                       //
//                                                                            //
// All rights reserved.                                                       //
// ========================================================================== //

// ========================================================================== //
// INCLUDES                                                                   //
// ========================================================================== //
# include "UCartMesh.hpp"

// ========================================================================== //
// METHODS IMPLEMENTATIONS FOR UCartMesh                              //
// ========================================================================== //

// Constructors ------------------------------------------------------------- //

// -------------------------------------------------------------------------- //
UCartMesh::UCartMesh(
        void
        ) {

    // ========================================================================== //
    // UCartMesh::UCartMesh(                                      //
    //     void)                                                                  //
    //                                                                            //
    // Default constructor for UCartMesh variables.                       //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    // none

    // ========================================================================== //
    // INITIALIZE DATA STRUCTURE                                                  //
    // ========================================================================== //

    dim = 3 ;

    // Mesh extent
    B0.fill(0.0) ;
    B1.fill(0.0) ;

    // Mesh size
    nc.fill(0);

    center.resize(3) ;
    edge.resize(3) ;

    // Mesh spacing
    h.fill(0.0);


    whichDirection[0] = 0 ;
    whichDirection[1] = 0 ;
    whichDirection[2] = 1 ;
    whichDirection[3] = 1 ;
    whichDirection[4] = 2 ;
    whichDirection[5] = 2 ;

    whichStep[0] = -1 ;
    whichStep[1] = +1 ;
    whichStep[2] = -1 ;
    whichStep[3] = +1 ;
    whichStep[4] = -1 ;
    whichStep[5] = +1 ;

    return; 
};

// -------------------------------------------------------------------------- //
UCartMesh::UCartMesh(
        darray3E        &P0,
        darray3E        &P1,
        iarray3E        &N ,
        int             dimension
        ) :UCartMesh() {

    // ========================================================================== //
    // UCartMesh::UCartMesh(                                      //
    //     dvector1D       &x,                                                    //
    //     dvector1D       &y,                                                    //
    //     int              n_x,                                                  //
    //     int              n_y)                                                  //
    //                                                                            //
    // Custom constructor for UCartMesh variables.                        //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - x     : dvector1D, mesh limits in the x direction                        //
    // - y     : dvector1D, mesh limits in the y direction                        //
    // - n_x   : int, number of cells in the x direction                          //
    // - n_y   : int, number of cells in the y direction                          //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    // none

    // ========================================================================== //
    // SET MESH                                                                   //
    // ========================================================================== //


    setMesh( P0, P1, N, dimension);


    return; 
};

// Assignament operator ----------------------------------------------------- //
UCartMesh& UCartMesh::operator=(
        const UCartMesh &B
        ) {

    // ========================================================================== //
    // UCartMesh& UCartMesh::operator=(                           //
    //     const UCartMesh &B)                                            //
    //                                                                            //
    // Assignament operator for UCartMesh variables. Copy mesh B into     //
    // *this. All data previously stored in *this are overwritten.                //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - B      : UCartMesh, source cartesian mesh                        //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - *this  : UCartMesh, copy of B                                    //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    // none

    // ========================================================================== //
    // COPY MESH                                                                  //
    // ========================================================================== //

    // Parameters --------------------------------------------------------------- //

    // Number of cells
    nc = B.nc;
    np = B.np;

    h = B.h;

    CellsInIJPlane = B.CellsInIJPlane ;
    PointsInIJPlane = B.PointsInIJPlane ;

    nCells = B.nCells ;
    nPoints = B.nPoints ;

    // Mesh limits
    B0 = B.B0;
    B1 = B.B1;

    // Resize mesh data structure ----------------------------------------------- //
    ResizeMesh();

    // Copy cell edges and cell centers ----------------------------------------- //
    edge = B.edge;
    center = B.center;

    return(*this); 
};

// Destructors -------------------------------------------------------------- //

// -------------------------------------------------------------------------- //
UCartMesh::~UCartMesh(
        void
        ) {

    // ========================================================================== //
    //  UCartMesh::~UCartMesh(                                    //
    //     void)                                                                  //
    //                                                                            //
    // Default denstructor for UCartMesh variables.                       //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    // none

    // ========================================================================== //
    // DESTROY DATA STRUCTURE                                                     //
    // ========================================================================== //

    // Destroy vector with cells data
//    for( int d=0; d<3; ++d){
//        dvector1D().swap(center[d]);
//        dvector1D().swap(edge[d]);
//    };


};

// Methods ------------------------------------------------------------------ //

// -------------------------------------------------------------------------- //
int UCartMesh::getNCells(){
    
    return nCells ;
};

// -------------------------------------------------------------------------- //
int UCartMesh::getNCells( int d){
    
    return nc[d] ;
};

// -------------------------------------------------------------------------- //
int UCartMesh::getNPoints(){
    
    return nPoints  ;
};

// -------------------------------------------------------------------------- //
int UCartMesh::getNPoints( int d){
    
    return np[d]  ;
};

// -------------------------------------------------------------------------- //
void UCartMesh::getBoundingBox( darray3E &A0, darray3E &A1){

    A0 = B0; 
    A1 = B1; 

    return ;
}

// -------------------------------------------------------------------------- //
darray3E UCartMesh::getCenter( int i, int j, int k ){

    darray3E    P ;

    P[0]= center[0][i] ;
    P[1]= center[1][j] ;
    P[2]= center[2][k] ;

    return P;
    
} ;

// -------------------------------------------------------------------------- //
darray3E UCartMesh::getCenter( iarray3E id ){

    darray3E    P ;

    P[0]= center[0][id[0]] ;
    P[1]= center[1][id[1]] ;
    P[2]= center[2][id[2]] ;

    return P;
    
} ;

// -------------------------------------------------------------------------- //
darray3E UCartMesh::getCenter( int J ){

    return  getCenter( CellCartesianId(J) );

};

// -------------------------------------------------------------------------- //
darray3E UCartMesh::getPoint( int i, int j, int k ){

    darray3E    P ;

    P[0]= edge[0][i] ;
    P[1]= edge[1][j] ;
    P[2]= edge[2][k] ;

    return P;

} ;

// -------------------------------------------------------------------------- //
darray3E UCartMesh::getPoint( iarray3E id ){

    darray3E    P ;

    P[0]= edge[0][id[0]] ;
    P[1]= edge[1][id[1]] ;
    P[2]= edge[2][id[2]] ;

    return P;

} ;

// -------------------------------------------------------------------------- //
darray3E UCartMesh::getPoint( int J ){

    return  getPoint( PointCartesianId(J) );

};

// -------------------------------------------------------------------------- //
darray3E UCartMesh::getFirstPointOfCell( int J ){

    return  getPoint( CellCartesianId(J) );

};

// -------------------------------------------------------------------------- //
darray3E UCartMesh::getLastPointOfCell( int J ){

    int         d ;
    iarray3E    ic ;

    ic = CellCartesianId(J) ;

    for( d=0; d<dim; ++d){
        ic[d]++ ;
    };

    return  getPoint( ic );

};




// -------------------------------------------------------------------------- //
void UCartMesh::ClearMesh(
        void
        ) {

    // ========================================================================== //
    // void UCartMesh::ClearMesh(                                         //
    //     void)                                                                  //
    //                                                                            //
    // Destroy current mesh.                                                      //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    // none

    // ========================================================================== //
    // DESTROY CURRENT MESH                                                       //
    // ========================================================================== //

    // Mesh limits
    B0.fill(0.0) ;
    B1.fill(0.0) ;

    h.fill(0.0) ;

    // Number of cells
    nc.fill(0) ;

    // Resize mesh data structure
    ResizeMesh();

    return; 
}

// -------------------------------------------------------------------------- //
void UCartMesh::ResizeMesh(
        void
        ) {

    // ========================================================================== //
    //  void UCartMesh::ResizeMesh(                                       //
    //     void)                                                                  //
    //                                                                            //
    // Resize mesh data structure according to mesh dimensions                    //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    int d ;  

    // ========================================================================== //
    // RESIZE DATA STRCTURE                                                       //
    // ========================================================================== //

    // Cell centers

    for( d=0; d<3; ++d){
        center[d].resize( nc[d], 0.0 ) ;
        edge[d].resize( np[d], 0.0);
    };

    return; 
};

// -------------------------------------------------------------------------- //
darray3E    UCartMesh::getSpacing(){
    return h ;
};

// -------------------------------------------------------------------------- //
double      UCartMesh::getSpacing( int d){
    return h[d] ;
};

// -------------------------------------------------------------------------- //
int      UCartMesh::getDim( ){
    return dim ;
};

// -------------------------------------------------------------------------- //
int      UCartMesh::getPointNeighbour( const int &I, const int &dir){

    int         d = whichDirection[dir], step = whichStep[dir];

    return  getPointNeighbour(I,d,step) ;
};

// -------------------------------------------------------------------------- //
int      UCartMesh::getPointNeighbour( const int &I, const int &d, const int &step){

    iarray3E    i;

    i       = PointCartesianId(I) ;
    i[d]    += step ; 
    i[d]    = max( min( i[d], nc[d] ), 0 ) ;

    return  PointLinearId(i) ;
};

// -------------------------------------------------------------------------- //
int      UCartMesh::getCellNeighbour( const int &I, const int &dir){

    int         d = whichDirection[dir], step = whichStep[dir];

    return  getCellNeighbour(I,d,step) ;
};

// -------------------------------------------------------------------------- //
int      UCartMesh::getCellNeighbour( const int &I, const int &d, const int &step){

    iarray3E    i;

    i       = CellCartesianId(I) ;
    i[d]    += step ; 
    i[d]    = max( min( i[d], nc[d]-1 ), 0 ) ;

    return  CellLinearId(i) ;
};
// -------------------------------------------------------------------------- //
void UCartMesh::setMesh(
        darray3E        &A0,
        darray3E        &A1,
        iarray3E        &N ,
        int             dimensions
        ) {

    // ========================================================================== //
    // void UCartMesh::setMesh(                                           //
    //     dvector1D       &x,                                                    //
    //     dvector1D       &y,                                                    //
    //     int              n_x,                                                  //
    //     int              n_y)                                                  //
    //                                                                            //
    // Generate mesh.                                                             //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - x     : dvector1D, mesh limits in the x direction                        //
    // - y     : dvector1D, mesh limits in the y direction                        //
    // - n_x   : int, number of cells in the x direction                          //
    // - n_y   : int, number of cells in the y direction                          //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    int       i, d;

    // ========================================================================== //
    // INITIALIZE MEMBERS                                                         //
    // ========================================================================== //

    dim             = dimensions ;
    nc              = N ;
    np              = N + 1;

    if( dim ==2 ){
        nc[2] = 1 ;
        np[2] = 1 ;
    };

    nCells          = nc[0]*nc[1]*nc[2] ;
    nPoints         = np[0]*np[1]*np[2] ;
    CellsInIJPlane  = nc[0]*nc[1] ;
    PointsInIJPlane = np[0]*np[1] ;


    // Mesh limits
    B0 = A0 ;
    B1 = A1 ;

    // Number of mesh cells

    // Resize mesh data structure ----------------------------------------------- //
    ResizeMesh();

    // Create mesh -------------------------------------------------------------- //

    // Mesh spacing
    for( d=0; d<dim; ++d){
        h[d] = (B1[d] - B0[d])/((double) nc[d]);
    };

    // vetices
    for( d=0; d<dim; ++d){

        for( i=0; i<np[d]; ++i){
            edge[d][i] = B0[d] + ((double) i) * h[d];
        };

    };


    // Cells centers
    for( d=0; d<dim; ++d){

        for( i=0; i<nc[d]; ++i){
            center[d][i] = edge[d][i] + 0.5 *h[d] ;
        };
    };

    return; 

};

// -------------------------------------------------------------------------- //
void UCartMesh::Translate(
        darray3E &ds
        ) {

    // ========================================================================== //
    // void UCartMesh::Translate(                                         //
    //     dvector1D &ds)                                                         //
    //                                                                            //
    // Translate mesh along x, y axis.                                            //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - ds   : dvector1D, with displacement along each direction.                //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    int     d;

    // ========================================================================== //
    // TRANSLATE MESH                                                             //
    // ========================================================================== //

    // Mesh limits
    B0 = B0 + ds;
    B1 = B1 + ds;

    // Cells edges
    for( d=0; d<dim; ++d){
        edge[d] = edge[d] + ds[d] ;
        center[d] = center[d] + ds[d] ;
    };
    return; 
};

// -------------------------------------------------------------------------- //
void UCartMesh::Scale(
        darray3E       &s,
        darray3E       origin
        ) {

    // ========================================================================== //
    // void UCartMesh::Scale(                                             //
    //     dvector1D       &s)                                                    //
    //                                                                            //
    // Scale mesh along each axis.                                                //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - s  : dvector1D, scaling factor along x, y directions                     //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    int     d;

    // ========================================================================== //
    // RESCALE MESH                                                               //
    // ========================================================================== //

    h = h *s;

    // Mesh limits
    for( d=0; d<dim; ++d){
        B0[d] = origin[d] +s[d] *( B0[d] - origin[d]) ;
        B1[d] = origin[d] +s[d] *( B1[d] - origin[d]) ;

        edge[d] = origin[d] +s[d] *( edge[d] - origin[d]) ;

        center[d] = origin[d] +s[d] *( center[d] - origin[d]) ;
    };

    return; 

};

// -------------------------------------------------------------------------- //
void UCartMesh::Scale(
        darray3E       &s
        ) {

    // ========================================================================== //
    // void UCartMesh::Scale(                                             //
    //     dvector1D       &s)                                                    //
    //                                                                            //
    // Scale mesh along each axis.                                                //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - s  : dvector1D, scaling factor along x, y directions                     //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters

    // ========================================================================== //
    // RESCALE MESH                                                               //
    // ========================================================================== //
    //

    Scale( s, B0);


    return; 

};

// -------------------------------------------------------------------------- //
iarray3E UCartMesh::CellCartesianId(
        const darray3E   &P
        ) {

    // ========================================================================== //
    // void UCartMesh::ReturnCellID(                                      //
    //     dvector1D   &P,                                                        //
    //     int         &i,                                                        //
    //     int         &j)                                                        //
    //                                                                            //
    // Returns the cartesian indices of the cell enclosing the point P.           //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - P      : dvector1D, point x, y coordinates                               //
    // - i, j   : int, cartesian indices of the cell enclosing the point P        //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    // none

    // Counters
    int         d ;
    iarray3E    id;

    id.fill(0) ;

    // ========================================================================== //
    // COMPUTE THE CELL ID                                                        //
    // ========================================================================== //

    for( d=0; d<dim; ++d){
        id[d] = min( nc[d]-1, max(0, (int) floor( (P[d] - B0[d])/h[d] )) );
    };

    return id; 
};

// -------------------------------------------------------------------------- //
int UCartMesh::CellLinearId(
        const darray3E   &P
        ) {

    // Counters
    int         n ;
    iarray3E    id;


    id = CellCartesianId(P) ;
    n  = CellLinearId(id) ;

    return n; 

};

// -------------------------------------------------------------------------- //
int UCartMesh::CellLinearId(
        int          i,
        int          j,
        int          k
        ) {

    // ========================================================================== //
    // int UCartMesh::AccessCell(                                     //
    //     int          i,                                                        //
    //     int          j)                                                        //
    //                                                                            //
    // Returns the rectilinear index of a cell given its cartesian indices.       //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - i, j     : int, cell's cartesian indices                                 //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - index    : int, cell index                                               //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    int     index;

    // Counters
    // none

    // ========================================================================== //
    // COMPUTE THE RECTILINEAR INDEX                                              //
    // ========================================================================== //

    index = CellsInIJPlane*k + nc[0]*j +i;

    return(index); 
};

// -------------------------------------------------------------------------- //
int UCartMesh::CellLinearId(
        iarray3E    id 
        ) {

    // ========================================================================== //
    // int UCartMesh::AccessCell(                                     //
    //     int          i,                                                        //
    //     int          j)                                                        //
    //                                                                            //
    // Returns the rectilinear index of a cell given its cartesian indices.       //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - i, j     : int, cell's cartesian indices                                 //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - index    : int, cell index                                               //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables

    // Counters
    // none

    return( CellLinearId(id[0], id[1], id[2] ) ); 
};

// -------------------------------------------------------------------------- //
iarray3E UCartMesh::CellCartesianId(
        int          J
        ) {

    // ========================================================================== //
    // void UCartMesh::AccessCell(                                    //
    //     int          J,                                                        //
    //     int         &i,                                                        //
    //     int         &j)                                                        //
    //                                                                            //
    // Returns cartesian indices of a cell given its global index.                //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - J        : int, cell global index                                        //
    // - i, j     : int, cell's cartesian indices                                 //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    iarray3E    id ;

    // Counters
    // none

    // ========================================================================== //
    // COMPUTE CARTESIAN INDICES                                                  //
    // ========================================================================== //

    id[0] = J % nc[0] ;
    id[2] = J / CellsInIJPlane;
    id[1] =  (J - id[2] *CellsInIJPlane ) /nc[0]  ;


    return id; 
};

// -------------------------------------------------------------------------- //
iarray3E UCartMesh::PointCartesianId(
        const darray3E   &P
        ) {

    int         d ;
    iarray3E    id;

    id.fill(0) ;

    for( d=0; d<dim; ++d){
        id[d] = min( np[d]-1, max(0, (int) round( (P[d] - B0[d])/h[d] )) );
    };

    return id; 
};

// -------------------------------------------------------------------------- //
int UCartMesh::PointLinearId(
        const darray3E   &P
        ) {

    // Counters
    iarray3E    id;


    id = PointCartesianId(P) ;

    return PointLinearId(id); 

};

// -------------------------------------------------------------------------- //
int UCartMesh::PointLinearId(
        int          i,
        int          j,
        int          k
        ) {

    // ========================================================================== //
    // int UCartMesh::AccessPoint(                                    //
    //     int          i,                                                        //
    //     int          j)                                                        //
    //                                                                            //
    // Returns the rectilinear index of a mesh vertex given its cartesian indices //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - i, j   : int, cartesian indices of mesh vertex                           //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - index  : int, rectilinear index of mesh vertex                           //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    int       index;

    // Counters
    // none

    // ========================================================================== //
    // COMPUTE THE RECTILINER INDEX                                               //
    // ========================================================================== //
    index = PointsInIJPlane *k + np[0]*j + i; 

    return (index); 

};

// -------------------------------------------------------------------------- //
int UCartMesh::PointLinearId(
        iarray3E     id
        ) {

    // ========================================================================== //
    // int UCartMesh::AccessPoint(                                    //
    //     int          i,                                                        //
    //     int          j)                                                        //
    //                                                                            //
    // Returns the rectilinear index of a mesh vertex given its cartesian indices //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - i, j   : int, cartesian indices of mesh vertex                           //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - index  : int, rectilinear index of mesh vertex                           //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables

    // Counters
    // none

    // ========================================================================== //
    // COMPUTE THE RECTILINER INDEX                                               //
    // ========================================================================== //

    return ( PointLinearId(id[0], id[1], id[2] ) ); 

};

// -------------------------------------------------------------------------- //
iarray3E UCartMesh::PointCartesianId(
        int          J
        ) {

    // ========================================================================== //
    // void UCartMesh::AccessPoint(                                   //
    //     int          J,                                                        //
    //     int         &i,                                                        //
    //     int         &j)                                                        //
    //                                                                            //
    // Returns cartesian indices of a mesh vertex given its global index.         //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - J      : int, vertex global index                                        //
    // - i, j   : int, cartesian indices of mesh vertex                           //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    iarray3E    id ;

    // Counters
    // none

    // ========================================================================== //
    // COMPUTE CARTESIAN INDICES                                                  //
    // ========================================================================== //

    id[0] = J % np[0] ;
    id[2] = J / PointsInIJPlane;
    id[1] =  (J - id[2] *PointsInIJPlane ) /np[0]  ;

    return id; 

};


// -------------------------------------------------------------------------- //
void UCartMesh::Cart2Unstr(
        int         &nV,
        int         &nS,
        dvecarr3E   &V,
        ivector2D   &S,
        ivector3D   &A
        ) {

    // ========================================================================== //
    // void UCartMesh::Cart2SurfMesh(                                     //
    //     int         &nV,                                                       //
    //     int         &nS,                                                       //
    //     dvector2D   &V,                                                        //
    //     ivector2D   &S,                                                        //
    //     ivector3D   &A)                                                        //
    //                                                                            //
    // Convertes cartesian mesh into unstructured mesh.                           //
    // ========================================================================== //
    // INPUT                                                                      //
    // ========================================================================== //
    // - nV         : int, number of mesh vertices                                //
    // - nS         : int, number of mesh simplicies                              //
    // - V          : dvector2D, coordinate vertex list. V[i][0], V[i][1], and    //
    //                V[i][2] are the x, y, z coordinates of the i-th vertex.     //
    // - S          : ivector2D, simplex-vertex connectivity. S[i][0], S[i][1],   //
    //                and S[i][2] are the global indices of vertices of the i-th  //
    //                simplex                                                     //
    // - A          : ivector3D, simplex-simplex adjacencies. A[i][j] are the     //
    //                global indices of simplicies adjacent to i-th simplex       //
    //                along the j-th face.                                        //
    // ========================================================================== //
    // OUTPUT                                                                     //
    // ========================================================================== //
    // - none                                                                     //
    // ========================================================================== //

    // ========================================================================== //
    // VARIABLES DECLARATION                                                      //
    // ========================================================================== //

    // Local variables
    int         nv, ns;

    // Counters
    int         i, j, k, J;

    // ========================================================================== //
    // RESIZE INPUT VARIABLES                                                     //
    // ========================================================================== //

    // Number of new vertices/simplicies
    nv = nPoints ;
    ns = nCells ;

    // Resize vertex list
    V.resize(nV + nv);

    // Resize simplex list
    S.resize(nS + ns, ivector1D(pow(2,dim), -1));

    // Resize adjacency
    A.resize(nS + ns, ivector2D(2*dim, ivector1D(1, -1)));

    // ========================================================================== //
    // GENERATE VERTEX LIST                                                       //
    // ========================================================================== //
    for (k = 0; k < np[2]; k++) {
        for (j = 0; j < np[1]; j++) {
            for (i = 0; i < np[0]; i++) {
                J = PointLinearId(i,j,k);
                V[J][0] = edge[0][i] ;
                V[J][1] = edge[1][j] ;
                V[J][2] = edge[2][k] ; 
                nV++;
            };
        }
    } 

    // ========================================================================== //
    // SIMPLEX-VERTEX CONNECTIVITY                                                //
    // ========================================================================== //
    for (k = 0; k < nc[2]; k++) {
        for (j = 0; j < nc[1]; j++) {
            for (i = 0; i < nc[0]; i++) {
                J = CellLinearId(i,j,k);

                S[J][0] = PointLinearId(i,j,k);
                S[J][1] = PointLinearId(i+1,j,k);
                S[J][2] = PointLinearId(i,j+1,k);
                S[J][3] = PointLinearId(i+1,j+1,k);

                if(dim==3){
                    S[J][4] = PointLinearId(i,j,k+1);
                    S[J][5] = PointLinearId(i+1,j,k+1);
                    S[J][6] = PointLinearId(i,j+1,k+1);
                    S[J][7] = PointLinearId(i+1,j+1,k+1);
                }

            }
        }
    } 

    // ========================================================================== //
    // SIMPLEX-VERTEX ADJACENCY                                                   //
    // ========================================================================== //
    for (k = 0; k < nc[2]; k++) {
        for (j = 0; j < nc[1]; j++) {
            for (i = 0; i < nc[0]; i++) {
                J = CellLinearId(i,j);

                if (i != 0)     { A[J][0][0] = CellLinearId(i-1,j,k); }
                if (i != nc[0]) { A[J][1][0] = CellLinearId(i+1,j,k); }

                if (j != 0)     { A[J][2][0] = CellLinearId(i,j-1,k); }
                if (j != nc[1]) { A[J][3][0] = CellLinearId(i,j+1,k); }

                if (k != 0)     { A[J][4][0] = CellLinearId(i,j,k-1); }
                if (k != nc[2]) { A[J][5][0] = CellLinearId(i,j,k+1); }

            }
        }
    }

    return; 
}

// -------------------------------------------------------------------------------------- //
void UCartMesh::Export_vtr(string filename) {

    // ====================================================================================== //
    // void UCartMesh::Export_vtr(string &filename)                                   //
    //                                                                                        //
    // Export mesh data in a .vtr file.                                                       //
    // ====================================================================================== //
    // INPUT                                                                                  //
    // ====================================================================================== //
    // - filename     : string, .vtr file name                                                //
    // ====================================================================================== //
    // OUTPUT                                                                                 //
    // ====================================================================================== //
    // - none                                                                                 //
    // ====================================================================================== //

    // ====================================================================================== //
    // VARIABLES DECLARATION                                                                  //
    // ====================================================================================== //

    // Local variables
    ofstream         file_handle;

    // Counters
    // none

    // ====================================================================================== //
    // EXPORT MESH DATA                                                                       //
    // ====================================================================================== //

    // Open file
    Open_vtr(file_handle, trim(filename));

    // Export mesh data
    Write_vtrMeshData(file_handle, nc[0], nc[1], nc[2], edge[0], edge[1], edge[2] );

    // Close file
    Close_vtr(file_handle);

    return; 
};

//-------------------------------------------------------------------------- //
bool UCartMesh::PointInGrid(                                           // Point-in-triangle condition
        array<double, 3> const              &P            // (input) Point coordinatesertex
        ){


    int     d;

    for( d=0; d<dim; ++d){

        if( P[d]< B0[d] || P[d] > B1[d] ){
            return false;
        };
    };

    return true ;
};
