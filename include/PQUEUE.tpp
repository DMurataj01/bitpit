// ========================================================================== //
//                         - SORTING ALGORITHMS -                             //
//                                                                            //
// Functions for data sorting.                                                //
// ========================================================================== //
// INFO                                                                       //
// Author    : Alessandro Alaia                                               //
// Version   : v2.0                                                           //
//                                                                            //
// All rights reserved.                                                       //
// ========================================================================== //

// ========================================================================== //
// TEMPLATE IMPLEMENTATIONS FOR minPQUEUE                                     //
// ========================================================================== //

// Constructors ============================================================= //

// -------------------------------------------------------------------------- //
template <class T, class T1>
minPQUEUE<T, T1>::minPQUEUE(
    bool            flag_label,
    ivector2D      *map_
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// minPQUEUE<T, T1>::minPQUEUE(                                               //
//     bool            flag_label,                                            //
//     ivector2D      *map)                                                   //
//                                                                            //
// Standard constructor for min priority QUEUE.                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - flag_label  : bool, flag for key labelling ('true' assign labels to each //
//                 sorting key. 'false', sorting keys are not labelled)       //
// - map         : ivector2D* pointer to user defined map.                    //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// CREATE LIFO STACK                                                          //
// ========================================================================== //

// Max stack dimensions
MAXSTK = 10;

// Currenst stack size
heap_size = 0;

// Set flag
use_labels = flag_label;

// Pointers
map = map_;

// Initialize stack
IncreaseSTACK();

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
minPQUEUE<T, T1>::minPQUEUE(
    int             maxstack,
    bool            flag_label,
    ivector2D      *map_
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// minPQUEUE<T, T1>::minPQUEUE(                                               //
//     int             maxstack,                                              //
//     bool            flag_label,                                            //
//     ivector2D      *map)                                                   //
//                                                                            //
// Custom constructor #1 for min prioriry queue                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - maxstack    : int, maximal stack size before resize.                     //
// - flag_label  : bool, flag for key labelling ('true' assign labels to each //
//                 sorting key. 'false', sorting keys are not labelled)       //
// - map         : ivector2D* pointer to user defined map.                    //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// CREATE LIFO STACK                                                          //
// ========================================================================== //

// Max stack dimensions
MAXSTK = maxstack;

// Currenst stack size
heap_size = 0;

// Flags
use_labels = flag_label;

// Pointers
map = map_;

// Initialize stack
IncreaseSTACK();

return; };

// Destructors ============================================================== //

// -------------------------------------------------------------------------- //
template <class T, class T1>
minPQUEUE<T, T1>::~minPQUEUE(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// minPQUEUE<T, T1>::~minPQUEUE(                                              //
//     void)                                                                  //
//                                                                            //
// Standard destructor for min heap.                                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// DESTROY LIFO STACK                                                         //
// ========================================================================== //

// Maximal stack size
MAXSTK = 0;

// Current stack dimensions
heap_size = 0;

// Destroy items
keys.clear();
if (use_labels) { labels.clear(); }
map = NULL;

// Flags
use_labels = false;

return; };

// Methods ================================================================== //

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::clear(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::clear(                                              //
//     void)                                                                  //
//                                                                            //
// Clear min heap content.                                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// CLEAR CONTENT                                                              //
// ========================================================================== //
heap_size = 0;
keys.resize(MAXSTK);
if (use_labels) { labels.resize(MAXSTK); }

return; }

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::IncreaseSTACK(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::IncreaseSTACK(                                      //
//     void)                                                                  //
//                                                                            //
// Increase stack size.                                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// INCREASE STACK SIZE                                                        //
// ========================================================================== //

// stack
keys.resize(heap_size + MAXSTK);

// labels
if (use_labels) {
    labels.resize(heap_size + MAXSTK);
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::DecreaseSTACK(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::DecreaseSTACK(                                      //
//     void)                                                                  //
//                                                                            //
// Decrease stack size.                                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int           n = keys.size();

// Counters
// none

// ========================================================================== //
// DECREASE STACK SIZE                                                        //
// ========================================================================== //

// Stack
keys.resize(max(n - MAXSTK, MAXSTK));

// labels
if (use_labels) {
    labels.resize(max(n - MAXSTK, MAXSTK));
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1 >
void minPQUEUE<T, T1>::heapify(
    int                       i
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::heapify(                                            //
//     int                       i)                                           //
//                                                                            //
// Restore the min heap property on a binary tree for the i-th element.       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - i    : int, index of element to be moved up/downwards the binary tree.   //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int             L, R, idummy, imap;
T               dummy;
T1              dummy2;

// Counters
// none

// ========================================================================== //
// RESTORE THE MIN HEAP PROPERTY                                              //
// ========================================================================== //

// Index of childrens
L = 2*i + 1;
R = 2*(i + 1);

// Check children's key
if ((L < heap_size) && (keys[L] < keys[i])) {
    idummy = L;
}
else {
    idummy = i;
}
if ((R < heap_size) && (keys[R] < keys[idummy])) {
    idummy = R;
}

// Move up-heap
if (idummy != i) {
    dummy = keys[i];
    keys[i] = keys[idummy];
    keys[idummy] = dummy;
    if (use_labels) {
        dummy2 = labels[i];
        labels[i] = labels[idummy];
        labels[idummy] = dummy2;
    }
    if (map != NULL) {
        imap = (*map)[i][0];
        (*map)[i][0] = (*map)[idummy][0];
        (*map)[idummy][0] = imap;
        (*map)[(*map)[i][0]][1] = i;
        (*map)[(*map)[idummy][0]][1] = idummy;
    }
    heapify(idummy);
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::build_heap(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::build_heap(                                         //
//     void)                                                                  //
//                                                                            //
// Build min heap tree.                                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int                i;

// ========================================================================== //
// BUILD MIN HEAP                                                             //
// ========================================================================== //
for (i = (heap_size - 1)/2; i >= 0; i--) {
    heapify(i);
} //next i

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::extract(
    T                      &root,
    T1                     &root_label
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::extract(                                            //
//     T                      &root,                                          //
//     T1                     &root_label)                                    //
//                                                                            //
// Extract root of binary tree from min heap data structure, and returns its  //
// label.                                                                     //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - root        : T, root of binary tree                                     //
// - root_label  : T1, label of root of the binary tree.                      //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int        imap;

// Counters
// none

// ========================================================================== //
// EXTRACT HEAP MIN ELEMENT                                                   //
// ========================================================================== //

// Extract min element
if (heap_size == 0) {
    return;
}
root = keys[0];

// Update heap data structure
keys[0] = keys[heap_size-1];
if (use_labels) {
    root_label = labels[0];
    labels[0] = labels[heap_size-1];
}
if (map != NULL) {
    imap = (*map)[0][0];
    (*map)[0][0] = (*map)[heap_size-1][0];
    (*map)[heap_size-1][0] = imap;
    (*map)[imap][1] = heap_size-1;
    (*map)[(*map)[0][0]][1] = 0;
}

// Reduce stack dimensions
heap_size--;
if (heap_size <= keys.size() - MAXSTK) {
    DecreaseSTACK();
}

// Restore min-heap condition
heapify(0);

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::extract(
    T                      &root
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::extract(                                            //
//     T                      &root)                                          //
//                                                                            //
// Extract root of binary tree from min heap data structure.                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - root        : T1, root of binary tree                                    //
// - root_label  : T2, label of root of the binary tree.                      //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int        imap;

// Counters
// none

// ========================================================================== //
// EXTRACT HEAP MIN ELEMENT                                                   //
// ========================================================================== //

// Extract min element
if (heap_size == 0) {
    return;
}
root = keys[0];

// Update heap data structure
keys[0] = keys[heap_size-1];
if (map != NULL) {
    imap = (*map)[0][0];
    (*map)[0][0] = (*map)[heap_size-1][0];
    (*map)[heap_size-1][0] = imap;
    (*map)[imap][1] = heap_size-1;
    (*map)[(*map)[0][0]][1] = 0;
}

// Reduce stack dimensions
heap_size--;
if (heap_size <= keys.size() - MAXSTK) {
    DecreaseSTACK();
}

// Restore min-heap condition
heapify(0);

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::insert(
    T                      &key_new,
    T1                     &label_new
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::insert(                                             //
//     T                      &key_new,                                       //
//     T1                     &label_new)                                     //
//                                                                            //
// Insert new key (and its associated label) into a min heap                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - key_new   : T1, key to be inserted                                       //
// - label_new : T2, label of the new key                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// INSERT A NEW KEY                                                           //
// ========================================================================== //

// Insert key
if (heap_size+1 > keys.size()) {
    IncreaseSTACK();
}

// Add new key
keys[heap_size] = key_new;

// Update labels
if (use_labels) {
    labels[heap_size] = label_new;
}

// Update heap size
heap_size++;

// Restore max heap condition
modify(heap_size-1, key_new, label_new);

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::insert(
    T                      &key_new
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::insert(                                             //
//     T                      &key_new)                                       //
//                                                                            //
// Insert new key into a min heap                                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - key_new   : T1, key to be inserted                                       //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// INSERT A NEW KEY                                                           //
// ========================================================================== //

// Insert key
if (heap_size+1 > keys.size()) {
    IncreaseSTACK();
}

// Add new key
keys[heap_size] = key_new;

// Update heap size
heap_size++;

// Restore max heap condition
modify(heap_size-1, key_new);

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::modify(
    int                     i,
    T                      &key_new,
    T1                     &label_new
) {

// ========================================================================== //
// template <class T, class T1, class T2>                                     //
// void minPQUEUE<T, T1>::modify(                                             //
//     int                     i,                                             //
//     T                      &key_new,                                       //
//     T1                     &label_new)                                     //
//                                                                            //
// Modify key value for the i-th element in a min heap data structure.        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - i         : int, index of element whose key must be modified             //
// - key_new   : T1, key to be inserted                                       //
// - label_new : T2, label attached to the new key                            //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                 imap;
T                   dummy1;
T1                  dummy2;

// Counters
int                 j;

// ========================================================================== //
// INCREASE VALUE OF LAST KEY.                                                //
// ========================================================================== //
if (key_new > keys[i]) {

    // Update keys
    keys[i] = key_new;
    if (use_labels) {
        labels[i] = label_new;
    }

    // move down-heap
    heapify(i);

}
else {

    // Update keys
    keys[i] = key_new;
    if (use_labels) {
        labels[i] = label_new;
    }

    // move up-heap
    j = (i + 1)/2 - 1;
    while ((i > 0) && (keys[j] > keys[i])) {
        dummy1 = keys[i];
        keys[i] = keys[j];
        keys[j] = dummy1;
        if (use_labels) {
            dummy2 = labels[i];
            labels[i] = labels[j];
            labels[j] = dummy2;
        }
        if (map != NULL) {
            imap = (*map)[i][0];
            (*map)[i][0] = (*map)[j][0];
            (*map)[j][0] = imap;
            (*map)[(*map)[i][0]][1] = i;
            (*map)[(*map)[j][0]][1] = j;
        }
        i = j;
        j = (i + 1)/2 - 1;
    } //next parent
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::modify(
    int                    i,
    T                      &key_new
) {

// ========================================================================== //
// template <class T, class T1, class T2>                                     //
// void minPQUEUE<T, T1>::modify(                                             //
//     int                    i,                                              //
//     T                      &key_new)                                       //
//                                                                            //
// Modify key value for the i-th element in a min heap data structure.        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - i         : int, index of element whose key must be modified             //
// - key_new   : T1, key to be inserted                                       //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                 imap;
T                   dummy1;

// Counters
int                 j;

// ========================================================================== //
// INCREASE VALUE OF SELECTED KEY.                                            //
// ========================================================================== //
if (key_new > keys[i]) {

    // Update keys
    keys[i] = key_new;

    // move down-heap
    heapify(i);

}
else {

    // Update keys
    keys[i] = key_new;

    // move up-heap
    j = (i + 1)/2 - 1;
    while ((i > 0) && (keys[j] > keys[i])) {
        dummy1 = keys[i];
        keys[i] = keys[j];
        keys[j] = dummy1;
        if (map != NULL) {
            imap = (*map)[i][0];
            (*map)[i][0] = (*map)[j][0];
            (*map)[j][0] = imap;
            (*map)[(*map)[i][0]][1] = i;
            (*map)[(*map)[j][0]][1] = j;
        }
        i = j;
        j = (i + 1)/2 - 1;
    } //next parent
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void minPQUEUE<T, T1>::display(
    ostream    &out
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void minPQUEUE<T, T1>::display(                                            //
//     ostream    &out)                                                       //
//                                                                            //
// Display min heap content.                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - out     : ostream, output stream                                         //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int           i, j, k;

// ========================================================================== //
// DISPLAY MIN-HEAP INFO                                                      //
// ========================================================================== //

// General info ------------------------------------------------------------- //
out << "min heap:" << endl;
out << "heap size:         " << heap_size << endl;
out << "data struct. size: " << keys.size() << endl;
out << "max stack size:    " << MAXSTK << endl;

// heap content ------------------------------------------------------------- //
out << "min heap data:" << endl;
i = 0;
k = 0;
while (i < heap_size) {
    j = 0;
    while ((j < pow(2, k)) && (i < heap_size)) {
        out << "[" << keys[i];
        if (use_labels) {
            out << ", '" << labels[i] << "'";
        }
        out << "] ";
        i++;
        j++;
    } //next j
    out << endl;
    k++;
} //next i

return; }

// ========================================================================== //
// TEMPLATE IMPLEMENTATIONS FOR maxPQUEUE                                     //
// ========================================================================== //

// Constructors ============================================================= //

// -------------------------------------------------------------------------- //
template <class T, class T1>
maxPQUEUE<T, T1>::maxPQUEUE(
    bool            flag_label,
    ivector2D      *map_
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// maxPQUEUE<T, T1>::maxPQUEUE(                                               //
//     bool            flag_label,                                            //
//     ivector2D      *map)                                                   //
//                                                                            //
// Standard constructor for max priority QUEUE.                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - flag_label  : bool, flag for key labelling ('true' assign labels to each //
//                 sorting key. 'false', sorting keys are not labelled)       //
// - map         : ivector2D* pointer to user defined map.                    //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// CREATE LIFO STACK                                                          //
// ========================================================================== //

// Max stack dimensions
MAXSTK = 10;

// Currenst stack size
heap_size = 0;

// Set flag
use_labels = flag_label;

// Pointers
map = map_;

// Initialize stack
IncreaseSTACK();

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
maxPQUEUE<T, T1>::maxPQUEUE(
    int             maxstack,
    bool            flag_label,
    ivector2D      *map_
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// maxPQUEUE<T, T1>::maxPQUEUE(                                               //
//     int             maxstack,                                              //
//     bool            flag_label,                                            //
//     ivector2D      *map)                                                   //
//                                                                            //
// Custom constructor #1 for max prioriry queue                               //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - maxstack    : int, maximal stack size before resize.                     //
// - flag_label  : bool, flag for key labelling ('true' assign labels to each //
//                 sorting key. 'false', sorting keys are not labelled)       //
// - map         : ivector2D* pointer to user defined map.                    //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// CREATE LIFO STACK                                                          //
// ========================================================================== //

// Max stack dimensions
MAXSTK = maxstack;

// Currenst stack size
heap_size = 0;

// Flags
use_labels = flag_label;

// Pointers
map = map_;

// Initialize stack
IncreaseSTACK();

return; };

// Destructors ============================================================== //

// -------------------------------------------------------------------------- //
template <class T, class T1>
maxPQUEUE<T, T1>::~maxPQUEUE(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// maxPQUEUE<T, T1>::~maxPQUEUE(                                              //
//     void)                                                                  //
//                                                                            //
// Standard destructor for max heap.                                          //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// DESTROY LIFO STACK                                                         //
// ========================================================================== //

// Maximal stack size
MAXSTK = 0;

// Current stack dimensions
heap_size = 0;

// Destroy items
keys.clear();
if (use_labels) { labels.clear(); }
map = NULL;

// Flags
use_labels = false;

return; };

// Methods ================================================================== //

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::clear(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::clear(                                              //
//     void)                                                                  //
//                                                                            //
// Clear max heap content.                                                    //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// CLEAR CONTENT                                                              //
// ========================================================================== //
heap_size = 0;
keys.resize(MAXSTK);
if (use_labels) { labels.resize(MAXSTK); }

return; }

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::IncreaseSTACK(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::IncreaseSTACK(                                      //
//     void)                                                                  //
//                                                                            //
// Increase stack size.                                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// INCREASE STACK SIZE                                                        //
// ========================================================================== //

// stack
keys.resize(heap_size + MAXSTK);

// labels
if (use_labels) {
    labels.resize(heap_size + MAXSTK);
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::DecreaseSTACK(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::DecreaseSTACK(                                      //
//     void)                                                                  //
//                                                                            //
// Decrease stack size.                                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int           n = keys.size();

// Counters
// none

// ========================================================================== //
// DECREASE STACK SIZE                                                        //
// ========================================================================== //

// Stack
keys.resize(max(n - MAXSTK, MAXSTK));

// labels
if (use_labels) {
    labels.resize(max(n - MAXSTK, MAXSTK));
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1 >
void maxPQUEUE<T, T1>::heapify(
    int                       i
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::heapify(                                            //
//     int                       i)                                           //
//                                                                            //
// Restore the max heap property on a binary tree for the i-th element.       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - i    : int, index of element to be moved up/downwards the binary tree.   //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int             L, R, idummy, imap;
T               dummy;
T1              dummy2;

// Counters
// none

// ========================================================================== //
// RESTORE THE MIN HEAP PROPERTY                                              //
// ========================================================================== //

// Index of childrens
L = 2*i + 1;
R = 2*(i + 1);

// Check children's key
if ((L < heap_size) && (keys[L] > keys[i])) {
    idummy = L;
}
else {
    idummy = i;
}
if ((R < heap_size) && (keys[R] > keys[idummy])) {
    idummy = R;
}

// Move up-heap
if (idummy != i) {
    dummy = keys[i];
    keys[i] = keys[idummy];
    keys[idummy] = dummy;
    if (use_labels) {
        dummy2 = labels[i];
        labels[i] = labels[idummy];
        labels[idummy] = dummy2;
    }
    if (map != NULL) {
        imap = (*map)[i][0];
        (*map)[i][0] = (*map)[idummy][0];
        (*map)[idummy][0] = imap;
        (*map)[(*map)[i][0]][1] = i;
        (*map)[(*map)[idummy][0]][1] = idummy;
    }
    heapify(idummy);
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::build_heap(
    void
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::build_heap(                                         //
//     void)                                                                  //
//                                                                            //
// Build max heap tree.                                                       //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int                i;

// ========================================================================== //
// BUILD MIN HEAP                                                             //
// ========================================================================== //
for (i = (heap_size - 1)/2; i >= 0; i--) {
    heapify(i);
} //next i

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::extract(
    T                      &root,
    T1                     &root_label
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::extract(                                            //
//     T                      &root,                                          //
//     T1                     &root_label)                                    //
//                                                                            //
// Extract root of binary tree from max heap data structure, and returns its  //
// label.                                                                     //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - root        : T, root of binary tree                                     //
// - root_label  : T1, label of root of the binary tree.                      //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int        imap;

// Counters
// none

// ========================================================================== //
// EXTRACT HEAP MIN ELEMENT                                                   //
// ========================================================================== //

// Extract min element
if (heap_size == 0) {
    return;
}
root = keys[0];

// Update heap data structure
keys[0] = keys[heap_size-1];
if (use_labels) {
    root_label = labels[0];
    labels[0] = labels[heap_size-1];
}
if (map != NULL) {
    imap = (*map)[0][0];
    (*map)[0][0] = (*map)[heap_size-1][0];
    (*map)[heap_size-1][0] = imap;
    (*map)[imap][1] = heap_size-1;
    (*map)[(*map)[0][0]][1] = 0;
}

// Reduce stack dimensions
heap_size--;
if (heap_size <= keys.size() - MAXSTK) {
    DecreaseSTACK();
}

// Restore min-heap condition
heapify(0);

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::extract(
    T                      &root
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::extract(                                            //
//     T                      &root)                                          //
//                                                                            //
// Extract root of binary tree from max heap data structure.                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - root        : T1, root of binary tree                                    //
// - root_label  : T2, label of root of the binary tree.                      //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int        imap;

// Counters
// none

// ========================================================================== //
// EXTRACT HEAP MIN ELEMENT                                                   //
// ========================================================================== //

// Extract min element
if (heap_size == 0) {
    return;
}
root = keys[0];

// Update heap data structure
keys[0] = keys[heap_size-1];
if (map != NULL) {
    imap = (*map)[0][0];
    (*map)[0][0] = (*map)[heap_size-1][0];
    (*map)[heap_size-1][0] = imap;
    (*map)[imap][1] = heap_size-1;
    (*map)[(*map)[0][0]][1] = 0;
}

// Reduce stack dimensions
heap_size--;
if (heap_size <= keys.size() - MAXSTK) {
    DecreaseSTACK();
}

// Restore min-heap condition
heapify(0);

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::insert(
    T                      &key_new,
    T1                     &label_new
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::insert(                                             //
//     T                      &key_new,                                       //
//     T1                     &label_new)                                     //
//                                                                            //
// Insert new key (and its associated label) into a max heap                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - key_new   : T1, key to be inserted                                       //
// - label_new : T2, label of the new key                                     //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// INSERT A NEW KEY                                                           //
// ========================================================================== //

// Insert key
if (heap_size+1 > keys.size()) {
    IncreaseSTACK();
}

// Add new key
keys[heap_size] = key_new;

// Update labels
if (use_labels) {
    labels[heap_size] = label_new;
}

// Update heap size
heap_size++;

// Restore max heap condition
modify(heap_size-1, key_new, label_new);

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::insert(
    T                      &key_new
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::insert(                                             //
//     T                      &key_new)                                       //
//                                                                            //
// Insert new key into a max heap                                             //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - key_new   : T1, key to be inserted                                       //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
// none

// ========================================================================== //
// INSERT A NEW KEY                                                           //
// ========================================================================== //

// Insert key
if (heap_size+1 > keys.size()) {
    IncreaseSTACK();
}

// Add new key
keys[heap_size] = key_new;

// Update heap size
heap_size++;

// Restore max heap condition
modify(heap_size-1, key_new);

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::modify(
    int                     i,
    T                      &key_new,
    T1                     &label_new
) {

// ========================================================================== //
// template <class T, class T1, class T2>                                     //
// void maxPQUEUE<T, T1>::modify(                                             //
//     int                     i,                                             //
//     T                      &key_new,                                       //
//     T1                     &label_new)                                     //
//                                                                            //
// Modify key value for the i-th element in a max heap data structure.        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - i         : int, index of element whose key must be modified             //
// - key_new   : T1, key to be inserted                                       //
// - label_new : T2, label attached to the new key                            //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                 imap;
T                   dummy1;
T1                  dummy2;

// Counters
int                 j;

// ========================================================================== //
// INCREASE VALUE OF LAST KEY.                                                //
// ========================================================================== //
if (key_new < keys[i]) {

    // Update keys
    keys[i] = key_new;
    if (use_labels) {
        labels[i] = label_new;
    }

    // move down-heap
    heapify(i);

}
else {

    // Update keys
    keys[i] = key_new;
    if (use_labels) {
        labels[i] = label_new;
    }

    // move up-heap
    j = (i + 1)/2 - 1;
    while ((i > 0) && (keys[j] < keys[i])) {
        dummy1 = keys[i];
        keys[i] = keys[j];
        keys[j] = dummy1;
        if (use_labels) {
            dummy2 = labels[i];
            labels[i] = labels[j];
            labels[j] = dummy2;
        }
        if (map != NULL) {
            imap = (*map)[i][0];
            (*map)[i][0] = (*map)[j][0];
            (*map)[j][0] = imap;
            (*map)[(*map)[i][0]][1] = i;
            (*map)[(*map)[j][0]][1] = j;
        }
        i = j;
        j = (i + 1)/2 - 1;
    } //next parent
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::modify(
    int                    i,
    T                      &key_new
) {

// ========================================================================== //
// template <class T, class T1, class T2>                                     //
// void maxPQUEUE<T, T1>::modify(                                             //
//     int                    i,                                              //
//     T                      &key_new)                                       //
//                                                                            //
// Modify key value for the i-th element in a max heap data structure.        //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - i         : int, index of element whose key must be modified             //
// - key_new   : T1, key to be inserted                                       //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
int                 imap;
T                   dummy1;

// Counters
int                 j;

// ========================================================================== //
// INCREASE VALUE OF SELECTED KEY.                                            //
// ========================================================================== //
if (key_new < keys[i]) {

    // Update keys
    keys[i] = key_new;

    // move down-heap
    heapify(i);

}
else {

    // Update keys
    keys[i] = key_new;

    // move up-heap
    j = (i + 1)/2 - 1;
    while ((i > 0) && (keys[j] < keys[i])) {
        dummy1 = keys[i];
        keys[i] = keys[j];
        keys[j] = dummy1;
        if (map != NULL) {
            imap = (*map)[i][0];
            (*map)[i][0] = (*map)[j][0];
            (*map)[j][0] = imap;
            (*map)[(*map)[i][0]][1] = i;
            (*map)[(*map)[j][0]][1] = j;
        }
        i = j;
        j = (i + 1)/2 - 1;
    } //next parent
}

return; };

// -------------------------------------------------------------------------- //
template <class T, class T1>
void maxPQUEUE<T, T1>::display(
    ostream    &out
) {

// ========================================================================== //
// template <class T, class T1>                                               //
// void maxPQUEUE<T, T1>::display(                                            //
//     ostream    &out)                                                       //
//                                                                            //
// Display max heap content.                                                  //
// ========================================================================== //
// INPUT                                                                      //
// ========================================================================== //
// - out     : ostream, output stream                                         //
// ========================================================================== //
// OUTPUT                                                                     //
// ========================================================================== //
// - none                                                                     //
// ========================================================================== //

// ========================================================================== //
// VARIABLES DECLARATION                                                      //
// ========================================================================== //

// Local variables
// none

// Counters
int           i, j, k;

// ========================================================================== //
// DISPLAY MIN-HEAP INFO                                                      //
// ========================================================================== //

// General info ------------------------------------------------------------- //
out << "max heap:" << endl;
out << "heap size:         " << heap_size << endl;
out << "data struct. size: " << keys.size() << endl;
out << "max stack size:    " << MAXSTK << endl;

// heap content ------------------------------------------------------------- //
out << "max heap data:" << endl;
i = 0;
k = 0;
while (i < heap_size) {
    j = 0;
    while ((j < pow(2, k)) && (i < heap_size)) {
        out << "[" << keys[i];
        if (use_labels) {
            out << ", '" << labels[i] << "'";
        }
        out << "] ";
        i++;
        j++;
    } //next j
    out << endl;
    k++;
} //next i

return; }
